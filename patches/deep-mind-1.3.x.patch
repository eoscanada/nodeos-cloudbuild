diff --git a/.gitmodules b/.gitmodules
index 7d0f8a37f..60b7c51a1 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -26,7 +26,7 @@
 	url = https://github.com/EOSIO/magic_get
 [submodule "libraries/fc"]
 	path = libraries/fc
-	url = https://github.com/EOSIO/fc
+	url = git@github.com:eoscanada/eosio-fc-private
 [submodule "libraries/wabt"]
 	path = libraries/wabt
 	url = http://github.com/EOSIO/wabt
diff --git a/libraries/chain/CMakeLists.txt b/libraries/chain/CMakeLists.txt
index cf4c1be18..e59b1a10b 100644
--- a/libraries/chain/CMakeLists.txt
+++ b/libraries/chain/CMakeLists.txt
@@ -47,6 +47,7 @@ add_library( eosio_chain
 
 
 #             transaction_metadata.cpp
+             trace.cpp
              ${HEADERS}
              )
 
diff --git a/libraries/chain/apply_context.cpp b/libraries/chain/apply_context.cpp
index f7513debf..32144a221 100644
--- a/libraries/chain/apply_context.cpp
+++ b/libraries/chain/apply_context.cpp
@@ -101,9 +101,12 @@ void apply_context::exec()
 {
    _notified.push_back(receiver);
    trace = exec_one();
+   trx_context.action_id.increment();
+
    for( uint32_t i = 1; i < _notified.size(); ++i ) {
       receiver = _notified[i];
       trace.inline_traces.emplace_back( exec_one() );
+      trx_context.action_id.increment();
    }
 
    if( _cfa_inline_actions.size() > 0 || _inline_actions.size() > 0 ) {
@@ -292,6 +295,18 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
             gtx.expiration  = gtx.delay_until + fc::seconds(control.get_global_properties().configuration.deferred_trx_expiration_window);
 
             trx_size = gtx.set( trx );
+
+            if (eosio::chain::chain_config::deep_mind_enabled) {
+                dmlog("DEFRTRX MODIFY ${rev} ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx}",
+                        ("rev", db.revision()-1)
+                        ("action_id", trx_context.action_id.current())
+                        ("sender", receiver)
+                        ("sender_id", sender_id)
+                        ("payer", payer)
+                        ("published", gtx.published)
+                        ("delay", gtx.delay_until)
+                        ("trx", control.to_variant_with_abi(trx, fc::microseconds(5000000))));
+            }
          });
    } else {
       d.create<generated_transaction_object>( [&]( auto& gtx ) {
@@ -304,11 +319,26 @@ void apply_context::schedule_deferred_transaction( const uint128_t& sender_id, a
             gtx.expiration  = gtx.delay_until + fc::seconds(control.get_global_properties().configuration.deferred_trx_expiration_window);
 
             trx_size = gtx.set( trx );
+
+            if (eosio::chain::chain_config::deep_mind_enabled) {
+                dmlog("DEFRTRX CREATE ${rev} ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx}",
+                        ("rev", db.revision()-1)
+                        ("action_id", trx_context.action_id.current())
+                        ("sender", receiver)
+                        ("sender_id", sender_id)
+                        ("payer", payer)
+                        ("published", gtx.published)
+                        ("delay", gtx.delay_until)
+                        ("expiration", gtx.expiration)
+                        ("trx", control.to_variant_with_abi(trx, fc::microseconds(5000000))));
+            }
          });
    }
 
    EOS_ASSERT( control.is_ram_billing_in_notify_allowed() || (receiver == act.account) || (receiver == payer) || privileged,
                subjective_block_production_exception, "Cannot charge RAM to other accounts during notify." );
+
+   ram_trace::operation = "deferred_trx_add";
    add_ram_usage( payer, (config::billable_size_v<generated_transaction_object> + trx_size) );
 }
 
@@ -316,6 +346,16 @@ bool apply_context::cancel_deferred_transaction( const uint128_t& sender_id, acc
    auto& generated_transaction_idx = db.get_mutable_index<generated_transaction_multi_index>();
    const auto* gto = db.find<generated_transaction_object,by_sender_id>(boost::make_tuple(sender, sender_id));
    if ( gto ) {
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+        dmlog("DEFRTRX CANCEL ${rev} ${action_id} ${sender} ${sender_id}",
+                ("rev", db.revision()-1)
+                ("action_id", trx_context.action_id.current())
+                ("sender", receiver)
+                ("sender_id", sender_id)
+                ("payer", gto->payer));
+      }
+
+      ram_trace::operation = "deferred_trx_cancel";
       add_ram_usage( gto->payer, -(config::billable_size_v<generated_transaction_object> + gto->packed_trx.size()) );
       generated_transaction_idx.remove(*gto);
    }
@@ -332,6 +372,7 @@ const table_id_object& apply_context::find_or_create_table( name code, name scop
       return *existing_tid;
    }
 
+   ram_trace::operation = "create_table";
    update_db_usage(payer, config::billable_size_v<table_id_object>);
 
    return db.create<table_id_object>([&](table_id_object &t_id){
@@ -343,6 +384,7 @@ const table_id_object& apply_context::find_or_create_table( name code, name scop
 }
 
 void apply_context::remove_table( const table_id_object& tid ) {
+   ram_trace::operation = "remove_table";
    update_db_usage(tid.payer, - config::billable_size_v<table_id_object>);
    db.remove(tid);
 }
@@ -444,8 +486,23 @@ int apply_context::db_store_i64( uint64_t code, uint64_t scope, uint64_t table,
    });
 
    int64_t billable_size = (int64_t)(buffer_size + config::billable_size_v<key_value_object>);
+   ram_trace::operation = "primary_index_add";
    update_db_usage( payer, billable_size);
 
+   if (eosio::chain::chain_config::deep_mind_db_enabled) {
+      auto table_obj = tab;
+      dmlog("DB_OPERATION INS ${rev} ${action_id} ${payer} ${table_code} ${scope} ${table_name} ${primkey} ${data}",
+              ("rev", db.revision()-1)
+              ("action_id", trx_context.action_id.current())
+              ("payer", payer)
+              ("table_code", table_obj.code)
+              ("scope", table_obj.scope)
+              ("table_name", table_obj.table)
+              ("primkey", name(obj.primary_key))
+              ("data", to_hex(obj.value.data(),obj.value.size()))
+      );
+   }
+
    keyval_cache.cache_table( tab );
    return keyval_cache.add( obj );
 }
@@ -466,14 +523,30 @@ void apply_context::db_update_i64( int iterator, account_name payer, const char*
 
    if( account_name(obj.payer) != payer ) {
       // refund the existing payer
+      ram_trace::operation = "primary_index_update_remove_old_payer";
       update_db_usage( obj.payer,  -(old_size) );
       // charge the new payer
+      ram_trace::operation = "primary_index_update_add_new_payer";
       update_db_usage( payer,  (new_size));
    } else if(old_size != new_size) {
       // charge/refund the existing payer the difference
+      ram_trace::operation = "primary_index_update";
       update_db_usage( obj.payer, new_size - old_size);
    }
 
+   if (eosio::chain::chain_config::deep_mind_db_enabled) {
+      dmlog("DB_OPERATION UPD ${rev} ${action_id} ${payer} ${table_code} ${scope} ${table_name} ${primkey} ${data}",
+              ("rev", db.revision()-1)
+              ("action_id", trx_context.action_id.current())
+              ("payer", payer)
+              ("table_code", table_obj.code)
+              ("scope", table_obj.scope)
+              ("table_name", table_obj.table)
+              ("primkey", name(obj.primary_key))
+              ("data", to_hex(obj.value.data(),obj.value.size()))
+      );
+   }
+
    db.modify( obj, [&]( auto& o ) {
      o.value.resize( buffer_size );
      memcpy( o.value.data(), buffer, buffer_size );
@@ -489,6 +562,7 @@ void apply_context::db_remove_i64( int iterator ) {
 
 //   require_write_lock( table_obj.scope );
 
+   ram_trace::operation = "primary_index_remove";
    update_db_usage( obj.payer,  -(obj.value.size() + config::billable_size_v<key_value_object>) );
 
    db.modify( table_obj, [&]( auto& t ) {
@@ -496,6 +570,19 @@ void apply_context::db_remove_i64( int iterator ) {
    });
    db.remove( obj );
 
+   if (eosio::chain::chain_config::deep_mind_db_enabled) {
+      dmlog("DB_OPERATION REM ${rev} ${action_id} ${payer} ${table_code} ${scope} ${table_name} ${primkey} ${data}",
+              ("rev", db.revision()-1)
+              ("action_id", trx_context.action_id.current())
+              ("payer", obj.payer)
+              ("table_code", table_obj.code)
+              ("scope", table_obj.scope)
+              ("table_name", table_obj.table)
+              ("primkey", name(obj.primary_key))
+              ("data", to_hex(obj.value.data(),obj.value.size()))
+      );
+   }
+
    if (table_obj.count == 0) {
       remove_table(table_obj);
    }
diff --git a/libraries/chain/chain_config.cpp b/libraries/chain/chain_config.cpp
index 974675749..36069bed1 100644
--- a/libraries/chain/chain_config.cpp
+++ b/libraries/chain/chain_config.cpp
@@ -8,6 +8,9 @@
 
 namespace eosio { namespace chain {
 
+   bool chain_config::deep_mind_enabled(false);
+   bool chain_config::deep_mind_db_enabled(false);
+
    void chain_config::validate()const {
       EOS_ASSERT( target_block_net_usage_pct <= config::percent_100, action_validate_exception,
                   "target block net usage percentage cannot exceed 100%" );
diff --git a/libraries/chain/controller.cpp b/libraries/chain/controller.cpp
index 0cf0627fd..9450a0f87 100644
--- a/libraries/chain/controller.cpp
+++ b/libraries/chain/controller.cpp
@@ -684,6 +684,13 @@ struct controller_impl {
          trace->except = e;
          trace->except_ptr = std::current_exception();
          trace->elapsed = fc::time_point::now() - trx_context.start;
+
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+           dmlog("DEFRTRX FAILED ${rev} ${action_id}",
+                  ("rev", db.revision()-1)
+                  ("action_id", trx_context.action_id.current())
+           );
+         }
       }
       trx_context.undo();
 
diff --git a/libraries/chain/eosio_contract.cpp b/libraries/chain/eosio_contract.cpp
index 33a123981..874726475 100644
--- a/libraries/chain/eosio_contract.cpp
+++ b/libraries/chain/eosio_contract.cpp
@@ -121,6 +121,7 @@ void apply_eosio_newaccount(apply_context& context) {
    ram_delta += owner_permission.auth.get_billable_size();
    ram_delta += active_permission.auth.get_billable_size();
 
+   ram_trace::operation = "newaccount";
    context.add_ram_usage(create.name, ram_delta);
 
 } FC_CAPTURE_AND_RETHROW( (create) ) }
@@ -167,6 +168,7 @@ void apply_eosio_setcode(apply_context& context) {
    });
 
    if (new_size != old_size) {
+      ram_trace::operation = "setcode";
       context.add_ram_usage( act.account, new_size - old_size );
    }
 }
@@ -196,6 +198,7 @@ void apply_eosio_setabi(apply_context& context) {
    });
 
    if (new_size != old_size) {
+      ram_trace::operation = "setabi";
       context.add_ram_usage( act.account, new_size - old_size );
    }
 }
@@ -254,12 +257,14 @@ void apply_eosio_updateauth(apply_context& context) {
 
       int64_t new_size = (int64_t)(config::billable_size_v<permission_object> + permission->auth.get_billable_size());
 
+      ram_trace::operation = "updateauth_update";
       context.add_ram_usage( permission->owner, new_size - old_size );
    } else {
       const auto& p = authorization.create_permission( update.account, update.permission, parent_id, update.auth );
 
       int64_t new_size = (int64_t)(config::billable_size_v<permission_object> + p.auth.get_billable_size());
 
+      ram_trace::operation = "updateauth_create";
       context.add_ram_usage( update.account, new_size );
    }
 }
@@ -282,7 +287,7 @@ void apply_eosio_deleteauth(apply_context& context) {
       const auto& index = db.get_index<permission_link_index, by_permission_name>();
       auto range = index.equal_range(boost::make_tuple(remove.account, remove.permission));
       EOS_ASSERT(range.first == range.second, action_validate_exception,
-                 "Cannot delete a linked authority. Unlink the authority first. This authority is linked to ${code}::${type}.", 
+                 "Cannot delete a linked authority. Unlink the authority first. This authority is linked to ${code}::${type}.",
                  ("code", string(range.first->code))("type", string(range.first->message_type)));
    }
 
@@ -291,8 +296,8 @@ void apply_eosio_deleteauth(apply_context& context) {
 
    authorization.remove_permission( permission );
 
+   ram_trace::operation = "deleteauth";
    context.add_ram_usage( remove.account, -old_size );
-
 }
 
 void apply_eosio_linkauth(apply_context& context) {
@@ -334,6 +339,7 @@ void apply_eosio_linkauth(apply_context& context) {
             link.required_permission = requirement.requirement;
          });
 
+         ram_trace::operation = "linkauth";
          context.add_ram_usage(
             l.account,
             (int64_t)(config::billable_size_v<permission_link_object>)
@@ -354,6 +360,8 @@ void apply_eosio_unlinkauth(apply_context& context) {
    auto link_key = boost::make_tuple(unlink.account, unlink.code, unlink.type);
    auto link = db.find<permission_link_object, by_action_name>(link_key);
    EOS_ASSERT(link != nullptr, action_validate_exception, "Attempting to unlink authority, but no link found");
+
+   ram_trace::operation = "unlinkauth";
    context.add_ram_usage(
       link->account,
       -(int64_t)(config::billable_size_v<permission_link_object>)
diff --git a/libraries/chain/include/eosio/chain/apply_context.hpp b/libraries/chain/include/eosio/chain/apply_context.hpp
index 8a4f98a7c..aa0a115ea 100644
--- a/libraries/chain/include/eosio/chain/apply_context.hpp
+++ b/libraries/chain/include/eosio/chain/apply_context.hpp
@@ -196,6 +196,7 @@ class apply_context {
                  ++t.count;
                });
 
+               ram_trace::operation = "secondary_index_add";
                context.update_db_usage( payer, config::billable_size_v<ObjectType> );
 
                itr_cache.cache_table( tab );
@@ -204,6 +205,7 @@ class apply_context {
 
             void remove( int iterator ) {
                const auto& obj = itr_cache.get( iterator );
+               ram_trace::operation = "secondary_index_remove";
                context.update_db_usage( obj.payer, -( config::billable_size_v<ObjectType> ) );
 
                const auto& table_obj = itr_cache.get_table( obj.t_id );
@@ -236,7 +238,9 @@ class apply_context {
                int64_t billing_size =  config::billable_size_v<ObjectType>;
 
                if( obj.payer != payer ) {
+                  ram_trace::operation = "secondary_index_update_remove_old_payer";
                   context.update_db_usage( obj.payer, -(billing_size) );
+                  ram_trace::operation = "secondary_index_update_add_new_payer";
                   context.update_db_usage( payer, +(billing_size) );
                }
 
diff --git a/libraries/chain/include/eosio/chain/chain_config.hpp b/libraries/chain/include/eosio/chain/chain_config.hpp
index 7f62ff111..960117f47 100644
--- a/libraries/chain/include/eosio/chain/chain_config.hpp
+++ b/libraries/chain/include/eosio/chain/chain_config.hpp
@@ -17,6 +17,9 @@ namespace eosio { namespace chain {
  * values specified by the producers.
  */
 struct chain_config {
+   static bool deep_mind_enabled;
+   static bool deep_mind_db_enabled;
+
    uint64_t   max_block_net_usage;                 ///< the maxiumum net usage in instructions for a block
    uint32_t   target_block_net_usage_pct;          ///< the target percent (1% == 100, 100%= 10,000) of maximum net usage; exceeding this triggers congestion handling
    uint32_t   max_transaction_net_usage;           ///< the maximum objectively measured net usage that the chain will allow regardless of account limits
diff --git a/libraries/chain/include/eosio/chain/trace.hpp b/libraries/chain/include/eosio/chain/trace.hpp
index ad02baf5b..8863ee0e4 100644
--- a/libraries/chain/include/eosio/chain/trace.hpp
+++ b/libraries/chain/include/eosio/chain/trace.hpp
@@ -10,6 +10,10 @@
 
 namespace eosio { namespace chain {
 
+   struct ram_trace {
+       static const char* operation;
+   };
+
    struct account_delta {
       account_delta( const account_name& n, int64_t d):account(n),delta(d){}
       account_delta(){}
diff --git a/libraries/chain/include/eosio/chain/transaction_context.hpp b/libraries/chain/include/eosio/chain/transaction_context.hpp
index 3175994de..fb149b035 100644
--- a/libraries/chain/include/eosio/chain/transaction_context.hpp
+++ b/libraries/chain/include/eosio/chain/transaction_context.hpp
@@ -4,6 +4,17 @@
 
 namespace eosio { namespace chain {
 
+   class action_id {
+      public:
+        action_id(): id(0) {}
+
+        inline void increment() { id++; }
+        inline uint32_t current() { return id; }
+
+      private:
+        uint32_t id;
+   };
+
    class transaction_context {
       private:
          void init( uint64_t initial_net_usage);
@@ -88,6 +99,8 @@ namespace eosio { namespace chain {
          int64_t                       billed_cpu_time_us = 0;
          bool                          explicit_billed_cpu_time = false;
 
+         /// kept to track ids of action_traces push via this transaction
+         action_id                     action_id;
       private:
          bool                          is_initialized = false;
 
diff --git a/libraries/chain/trace.cpp b/libraries/chain/trace.cpp
new file mode 100644
index 000000000..3dadcdad6
--- /dev/null
+++ b/libraries/chain/trace.cpp
@@ -0,0 +1,7 @@
+#include <eosio/chain/trace.hpp>
+
+namespace eosio { namespace chain {
+
+const char* ram_trace::operation = NULL;
+
+}}
\ No newline at end of file
diff --git a/libraries/chain/transaction_context.cpp b/libraries/chain/transaction_context.cpp
index dd58f0364..e4eca0547 100644
--- a/libraries/chain/transaction_context.cpp
+++ b/libraries/chain/transaction_context.cpp
@@ -386,6 +386,18 @@ namespace eosio { namespace chain {
       if( ram_delta > 0 ) {
          validate_ram_usage.insert( account );
       }
+
+      if (eosio::chain::chain_config::deep_mind_enabled) {
+        dmlog("RAM_CONSUMED ${rev} ${action_id} ${operation} ${payer} ${delta}",
+                ("rev", control.db().revision()-1)
+                ("action_id", action_id.current())
+                ("operation", ram_trace::operation == NULL ? "n/a" : ram_trace::operation)
+                ("payer", account)
+                ("delta", ram_delta)
+        );
+
+        ram_trace::operation = NULL;
+      }
    }
 
    uint32_t transaction_context::update_billed_cpu_time( fc::time_point now ) {
@@ -460,8 +472,22 @@ namespace eosio { namespace chain {
         gto.delay_until = gto.published + delay;
         gto.expiration  = gto.delay_until + fc::seconds(control.get_global_properties().configuration.deferred_trx_expiration_window);
         trx_size = gto.set( trx );
+
+        if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog("DTRX_SCHEDULE ${rev} ${action_id} ${sender} ${sender_id} ${payer} ${published} ${delay} ${expiration} ${trx}",
+                    ("rev", control.db().revision()-1)
+                    ("action_id", action_id.current())
+                    ("sender", account_name())
+                    ("sender_id", gto.sender_id)
+                    ("payer", gto.payer)
+                    ("published", gto.published)
+                    ("delay", gto.delay_until)
+                    ("expiration", gto.expiration)
+                    ("trx", control.to_variant_with_abi(trx, fc::microseconds(5000000))));
+        }
       });
 
+      ram_trace::operation = "scheduled_trx_add";
       add_ram_usage( cgto.payer, (config::billable_size_v<generated_transaction_object> + trx_size) );
    }
 
Submodule libraries/fc 4dc8375d7..e23e56b7b:
diff --git a/libraries/fc/CMakeLists.txt b/libraries/fc/CMakeLists.txt
index 883fbbc..4db9ae9 100644
--- a/libraries/fc/CMakeLists.txt
+++ b/libraries/fc/CMakeLists.txt
@@ -71,6 +71,7 @@ set( fc_sources
      src/log/logger.cpp
      src/log/appender.cpp
      src/log/console_appender.cpp
+     src/log/deep_mind_appender.cpp
      src/log/gelf_appender.cpp
      src/log/logger_config.cpp
      src/crypto/_digest_common.cpp
@@ -119,7 +120,7 @@ set( sources
 list(APPEND sources ${fc_headers})
 
 setup_library( fc SOURCES ${sources} LIBRARY_TYPE STATIC DONT_INSTALL_LIBRARY )
-  
+
 IF(APPLE)
   # As of 10.10 yosemite, the OpenSSL static libraries shipped with os x have a dependency
   # on zlib, so any time you link in openssl you also need to link zlib.  .  We really want to detect whether openssl was configured with the --no-zlib
diff --git a/libraries/fc/include/fc/log/deep_mind_appender.hpp b/libraries/fc/include/fc/log/deep_mind_appender.hpp
new file mode 100644
index 0000000..a766851
--- /dev/null
+++ b/libraries/fc/include/fc/log/deep_mind_appender.hpp
@@ -0,0 +1,24 @@
+#pragma once
+#include <fc/log/appender.hpp>
+#include <fc/log/logger.hpp>
+#include <vector>
+
+namespace fc
+{
+   class deep_mind_appender : public appender
+   {
+       public:
+            deep_mind_appender( const variant& args );
+            deep_mind_appender();
+
+            ~deep_mind_appender();
+            void initialize( boost::asio::io_service& io_service ) {}
+
+            virtual void log( const log_message& m );
+
+       private:
+            class impl;
+            std::unique_ptr<impl> my;
+   };
+} // namespace fc
+
diff --git a/libraries/fc/include/fc/log/logger.hpp b/libraries/fc/include/fc/log/logger.hpp
index 9005d75..84f7289 100644
--- a/libraries/fc/include/fc/log/logger.hpp
+++ b/libraries/fc/include/fc/log/logger.hpp
@@ -4,7 +4,7 @@
 #include <fc/shared_ptr.hpp>
 #include <fc/log/log_message.hpp>
 
-namespace fc  
+namespace fc
 {
 
    class appender;
@@ -13,13 +13,13 @@ namespace fc
     *
     *
     @code
-      void my_class::func() 
+      void my_class::func()
       {
          fc_dlog( my_class_logger, "Format four: ${arg}  five: ${five}", ("arg",4)("five",5) );
       }
     @endcode
     */
-   class logger 
+   class logger
    {
       public:
          static logger get( const fc::string& name = "default");
@@ -104,6 +104,11 @@ namespace fc
       (fc::logger::get(DEFAULT_LOGGER)).log( FC_LOG_MESSAGE( debug, FORMAT, __VA_ARGS__ ) ); \
   FC_MULTILINE_MACRO_END
 
+#define dmlog( FORMAT, ... ) \
+  FC_MULTILINE_MACRO_BEGIN \
+   if( (fc::logger::get("deep-mind")).is_enabled( fc::log_level::debug ) ) \
+      (fc::logger::get("deep-mind")).log( FC_LOG_MESSAGE( debug, FORMAT, __VA_ARGS__ ) ); \
+  FC_MULTILINE_MACRO_END
 /**
  * Sends the log message to a special 'user' log stream designed for messages that
  * the end user may like to see.
@@ -148,19 +153,19 @@ namespace fc
   BOOST_PP_LPAREN() BOOST_PP_STRINGIZE(base),fc::variant(base) BOOST_PP_RPAREN()
 
 #define FC_FORMAT( SEQ )\
-    BOOST_PP_SEQ_FOR_EACH( FC_FORMAT_ARG, v, SEQ ) 
+    BOOST_PP_SEQ_FOR_EACH( FC_FORMAT_ARG, v, SEQ )
 
-// takes a ... instead of a SEQ arg because it can be called with an empty SEQ 
+// takes a ... instead of a SEQ arg because it can be called with an empty SEQ
 // from FC_CAPTURE_AND_THROW()
 #define FC_FORMAT_ARG_PARAMS( ... )\
-    BOOST_PP_SEQ_FOR_EACH( FC_FORMAT_ARGS, v, __VA_ARGS__ ) 
+    BOOST_PP_SEQ_FOR_EACH( FC_FORMAT_ARGS, v, __VA_ARGS__ )
 
 #define idump( SEQ ) \
-    ilog( FC_FORMAT(SEQ), FC_FORMAT_ARG_PARAMS(SEQ) )  
+    ilog( FC_FORMAT(SEQ), FC_FORMAT_ARG_PARAMS(SEQ) )
 #define wdump( SEQ ) \
-    wlog( FC_FORMAT(SEQ), FC_FORMAT_ARG_PARAMS(SEQ) )  
+    wlog( FC_FORMAT(SEQ), FC_FORMAT_ARG_PARAMS(SEQ) )
 #define edump( SEQ ) \
-    elog( FC_FORMAT(SEQ), FC_FORMAT_ARG_PARAMS(SEQ) )  
+    elog( FC_FORMAT(SEQ), FC_FORMAT_ARG_PARAMS(SEQ) )
 
 // this disables all normal logging statements -- not something you'd normally want to do,
 // but it's useful if you're benchmarking something and suspect logging is causing
@@ -176,4 +181,6 @@ namespace fc
 # define ilog(...) FC_MULTILINE_MACRO_BEGIN FC_MULTILINE_MACRO_END
 # undef dlog
 # define dlog(...) FC_MULTILINE_MACRO_BEGIN FC_MULTILINE_MACRO_END
+# undef dmlog
+# define dmlog(...) FC_MULTILINE_MACRO_BEGIN FC_MULTILINE_MACRO_END
 #endif
\ No newline at end of file
diff --git a/libraries/fc/src/log/appender.cpp b/libraries/fc/src/log/appender.cpp
index d504cfc..9b0ab7b 100644
--- a/libraries/fc/src/log/appender.cpp
+++ b/libraries/fc/src/log/appender.cpp
@@ -3,6 +3,7 @@
 #include <unordered_map>
 #include <string>
 #include <fc/log/console_appender.hpp>
+#include <fc/log/deep_mind_appender.hpp>
 #include <fc/log/file_appender.hpp>
 #include <fc/log/gelf_appender.hpp>
 #include <fc/variant.hpp>
@@ -43,6 +44,7 @@ namespace fc {
    }
 
    static bool reg_console_appender = appender::register_appender<console_appender>( "console" );
+   static bool reg_deep_mind_appender = appender::register_appender<deep_mind_appender>( "deep-mind" );
    //static bool reg_file_appender = appender::register_appender<file_appender>( "file" );
    static bool reg_gelf_appender = appender::register_appender<gelf_appender>( "gelf" );
 
diff --git a/libraries/fc/src/log/deep_mind_appender.cpp b/libraries/fc/src/log/deep_mind_appender.cpp
new file mode 100644
index 0000000..8bf79a9
--- /dev/null
+++ b/libraries/fc/src/log/deep_mind_appender.cpp
@@ -0,0 +1,43 @@
+#include <fc/log/deep_mind_appender.hpp>
+#include <fc/log/log_message.hpp>
+#include <fc/string.hpp>
+#include <fc/variant.hpp>
+#include <fc/reflect/variant.hpp>
+#ifndef WIN32
+#include <unistd.h>
+#endif
+#include <boost/thread/mutex.hpp>
+#include <fc/exception/exception.hpp>
+#include <iomanip>
+#include <mutex>
+#include <sstream>
+
+
+namespace fc {
+
+   class deep_mind_appender::impl {
+   public:
+     boost::mutex                log_mutex;
+   };
+
+   deep_mind_appender::deep_mind_appender( const variant& args )
+   :my(new impl){}
+
+   deep_mind_appender::deep_mind_appender()
+   :my(new impl){}
+
+   deep_mind_appender::~deep_mind_appender() {}
+
+   void deep_mind_appender::log( const log_message& m ) {
+      FILE* out = stdout;
+
+      std::stringstream line;
+      fc::string message = fc::format_string( m.get_format(), m.get_data() );
+      if (message.empty()) return;
+
+      std::unique_lock<boost::mutex> lock(my->log_mutex);
+
+      fprintf( out, "%s\n", message.c_str() );
+      fflush( out );
+   }
+}
diff --git a/libraries/fc/src/log/logger_config.cpp b/libraries/fc/src/log/logger_config.cpp
index 5643f57..0fc986d 100644
--- a/libraries/fc/src/log/logger_config.cpp
+++ b/libraries/fc/src/log/logger_config.cpp
@@ -5,6 +5,7 @@
 #include <unordered_map>
 #include <string>
 #include <fc/log/console_appender.hpp>
+#include <fc/log/deep_mind_appender.hpp>
 #include <fc/log/gelf_appender.hpp>
 #include <fc/reflect/variant.hpp>
 #include <fc/exception/exception.hpp>
@@ -22,6 +23,7 @@ namespace fc {
    {
       try {
       static bool reg_console_appender = appender::register_appender<console_appender>( "console" );
+      static bool reg_deep_mind_appender = appender::register_appender<deep_mind_appender>( "deep-mind" );
       static bool reg_gelf_appender = appender::register_appender<gelf_appender>( "gelf" );
       get_logger_map().clear();
       get_appender_map().clear();
@@ -47,7 +49,7 @@ namespace fc {
             if( ap ) { lgr.add_appender(ap); }
          }
       }
-      return reg_console_appender || reg_gelf_appender;
+      return reg_console_appender || reg_deep_mind_appender || reg_gelf_appender;
       } catch ( exception& e )
       {
          std::cerr<<e.to_detail_string()<<"\n";
@@ -77,11 +79,23 @@ namespace fc {
                      ( "level_colors", c )
                  ) );
 
+      cfg.appenders.push_back(
+             appender_config( "deep-mind", "deep-mind" )
+      );
+
       logger_config dlc;
       dlc.name = "default";
       dlc.level = log_level::debug;
       dlc.appenders.push_back("stderr");
+
+      logger_config dmlc;
+      dmlc.name = "deep-mind";
+      dmlc.level = log_level::debug;
+      dmlc.enabled = true;
+      dmlc.appenders.push_back("deep-mind");
+
       cfg.loggers.push_back( dlc );
+      cfg.loggers.push_back( dmlc );
       return cfg;
    }
 
diff --git a/plugins/chain_plugin/chain_plugin.cpp b/plugins/chain_plugin/chain_plugin.cpp
index 183e7a48e..423cb4920 100644
--- a/plugins/chain_plugin/chain_plugin.cpp
+++ b/plugins/chain_plugin/chain_plugin.cpp
@@ -221,6 +221,10 @@ void chain_plugin::set_program_options(options_description& cli, options_descrip
          ("reversible-blocks-db-guard-size-mb", bpo::value<uint64_t>()->default_value(config::default_reversible_guard_size / (1024  * 1024)), "Safely shut down node when free space remaining in the reverseible blocks database drops below this size (in MiB).")
          ("contracts-console", bpo::bool_switch()->default_value(false),
           "print contract's output to console")
+         ("deep-mind", bpo::bool_switch()->default_value(false),
+          "print tx traces and blocks to console")
+         ("deep-mind-db", bpo::bool_switch()->default_value(false),
+          "print db deltas to console")
          ("actor-whitelist", boost::program_options::value<vector<string>>()->composing()->multitoken(),
           "Account added to actor whitelist (may specify multiple times)")
          ("actor-blacklist", boost::program_options::value<vector<string>>()->composing()->multitoken(),
@@ -337,6 +341,9 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
          throw;
       }
 
+      eosio::chain::chain_config::deep_mind_enabled = options.at( "deep-mind" ).as<bool>();
+      eosio::chain::chain_config::deep_mind_db_enabled = options.at( "deep-mind-db" ).as<bool>();
+
       my->chain_config = controller::config();
 
       LOAD_VALUE_SET( options, "actor-whitelist", my->chain_config->actor_whitelist );
@@ -622,6 +629,12 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
             } );
 
       my->accepted_block_connection = my->chain->accepted_block.connect( [this]( const block_state_ptr& blk ) {
+         if (eosio::chain::chain_config::deep_mind_enabled) {
+            dmlog( "ACCEPTED_BLOCK ${num} ${blk}",
+              ("num", blk->block_num)
+              ("blk", chain().to_variant_with_abi(blk, fc::microseconds(5000000)))
+            );
+         }
          my->accepted_block_channel.publish( blk );
       } );
 
@@ -636,6 +649,12 @@ void chain_plugin::plugin_initialize(const variables_map& options) {
 
       my->applied_transaction_connection = my->chain->applied_transaction.connect(
             [this]( const transaction_trace_ptr& trace ) {
+               if (eosio::chain::chain_config::deep_mind_enabled) {
+                  dmlog( "HISTORY_TRACES ${block} ${traces}",
+                        ("traces", chain().to_variant_with_abi(trace, fc::microseconds(5000000)))
+                        ("block", chain().pending_block_state()->block_num)
+                  );
+               }
                my->applied_transaction_channel.publish( trace );
             } );
 
